{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"","level":1,"title":"ruby-prof","text":"<ul> <li>Getting Started - Command line, convenience API, core API</li> <li>Advanced Usage - Measurement modes, allocation tracking, thread filtering, method exclusion</li> <li>Reports - Flat, graph, HTML, call stack, call tree, graphviz</li> <li>Profiling Rails - Using ruby-prof with Rails applications</li> <li>Architecture - How ruby-prof works internally</li> </ul>","path":["ruby-prof"],"tags":[]},{"location":"#overview","level":2,"title":"Overview","text":"<p>ruby-prof is a profiler for MRI Ruby. Its features include:</p> <ul> <li>Speed - it is a C extension and therefore many times faster than the standard Ruby profiler.</li> <li>Measurement Modes - ruby-prof can measure program wall time, process time and object allocations.</li> <li>Reports - ruby-prof can generate a variety of text and cross-referenced html reports.</li> <li>Threads - supports profiling multiple threads simultaneously.</li> </ul>","path":["ruby-prof"],"tags":[]},{"location":"#why-ruby-prof","level":2,"title":"Why ruby-prof?","text":"<p>ruby-prof is helpful if your program is slow and you don't know why. It can help you track down methods that are either slow, allocate a large number of objects or allocate objects with high memory usage. Often times the results will be surprising - when profiling what you think you know almost always turns out to be wrong.</p> <p>Since ruby-prof is built using ruby's C tracepoint api, it knows a lot about your program. However, using ruby-prof also comes with two caveats:</p> <ul> <li>To use ruby-prof you generally need to include a few lines of extra code in your program (although see command line usage)</li> <li>Using ruby-prof will cause your program to run slower (see Performance section)</li> </ul> <p>Most of the time, these two caveats are acceptable. But if you need to determine why a program running in production is slow or hung, a sampling profiler will be a better choice. Excellent choices include stackprof or rbspy.</p> <p>If you are just interested in memory usage, you may also want to checkout the memory_profiler gem (although ruby-prof provides similar information).</p>","path":["ruby-prof"],"tags":[]},{"location":"#installation","level":2,"title":"Installation","text":"<p>The easiest way to install ruby-prof is by using Ruby Gems. To install:</p> <pre><code>gem install ruby-prof\n</code></pre> <p>If you are running Linux or Unix you'll need to have a C compiler installed so the extension can be built when it is installed. If you are running Windows, then you should install the Windows specific gem or install devkit.</p> <p>ruby-prof requires Ruby 3.0.0 or higher.</p>","path":["ruby-prof"],"tags":[]},{"location":"#performance","level":2,"title":"Performance","text":"<p>Significant effort has been put into reducing ruby-prof's overhead. Our tests show that the overhead associated with profiling code varies considerably with the code being profiled. Most programs will run approximately twice as slow while highly recursive programs (like the fibonacci series test) will run up to five times slower.</p>","path":["ruby-prof"],"tags":[]},{"location":"#version-history","level":2,"title":"Version History","text":"<p>For a full list of changes between versions, see the CHANGES file.</p> <p>Notable milestones:</p> <ul> <li>1.0 - Major rewrite with significantly faster profiling, correct recursive profile handling, redesigned reports, allocation/memory measurement without patched Ruby, and save/reload of profiling results.</li> <li>1.7 - Dropped Ruby 2.7 support, added Ruby 3.3 support.</li> <li>1.8 - Ruby 4.0 support. Removed <code>RubyProf::MEMORY</code> measurement mode (no longer works on Ruby 4.0).</li> </ul>","path":["ruby-prof"],"tags":[]},{"location":"#api-documentation","level":2,"title":"API Documentation","text":"<p>API documentation for each class is available at the ruby-prof API docs.</p>","path":["ruby-prof"],"tags":[]},{"location":"#license","level":2,"title":"License","text":"<p>See LICENSE for license information.</p>","path":["ruby-prof"],"tags":[]},{"location":"#development","level":2,"title":"Development","text":"<p>Code is located at github.com/ruby-prof/ruby-prof.</p>","path":["ruby-prof"],"tags":[]},{"location":"advanced-usage/","level":1,"title":"Advanced Usage","text":"<p>This section describes advanced usage of ruby-prof. Additional documentation for every class is also available.</p>","path":["Advanced Usage"],"tags":[]},{"location":"advanced-usage/#profiling-options","level":2,"title":"Profiling Options","text":"<p>ruby-prof understands the following options when profiling code:</p> <p>measure_mode - What ruby-prof should measure. For more information see the Measurement Mode section.</p> <p>track_allocations - Tracks each object location, including the object class, memory size and source file location. For more information see the Allocation Tracking section.</p> <p>exclude_threads - Array of threads which should not be profiled. For more information see the Thread Inclusion/Exclusion section.</p> <p>include_threads - Array of threads which should be profiled. All other threads will be ignored. For more information see the Thread Inclusion/Exclusion section.</p> <p>allow_exceptions - Whether to raise exceptions encountered during profiling, or to suppress them. Defaults to false.</p> <p>exclude_common - Automatically calls <code>exclude_common_methods!</code> to exclude commonly cluttering methods. Defaults to false. For more information see the Method Exclusion section.</p>","path":["Advanced Usage"],"tags":[]},{"location":"advanced-usage/#measurement-mode","level":2,"title":"Measurement Mode","text":"<p>The measurement mode determines what ruby-prof measures when profiling code. Supported measurements are:</p> <p>RubyProf::WALL_TIME - Wall time measures the real-world time elapsed between any two moments in seconds. If there are other processes concurrently running on the system that use significant CPU or disk time during a profiling run then the reported results will be larger than expected. On Windows, wall time is measured using <code>GetTickCount()</code>, on MacOS by <code>mach_absolute_time</code>, on Linux by <code>clock_gettime</code> and otherwise by <code>gettimeofday</code>.</p> <p>RubyProf::PROCESS_TIME - Process time measures the time used by a process between any two moments in seconds. It is unaffected by other processes concurrently running on the system. Remember with process time that calls to methods like sleep will not be included in profiling results. On Windows, process time is measured using <code>GetProcessTimes</code> and on other platforms by <code>clock_gettime</code>.</p> <p>RubyProf::ALLOCATIONS - Object allocations measures show how many objects each method in a program allocates. Measurements are done via Ruby's <code>GC.stat</code> api.</p> <p>To set the measurement mode:</p> <pre><code>profile = RubyProf::Profile.new(measure_mode: RubyProf::WALL_TIME)\nprofile = RubyProf::Profile.new(measure_mode: RubyProf::PROCESS_TIME)\nprofile = RubyProf::Profile.new(measure_mode: RubyProf::ALLOCATIONS)\n</code></pre> <p>The default value is <code>RubyProf::WALL_TIME</code>. You may also specify the measure mode by using the <code>RUBY_PROF_MEASURE_MODE</code> environment variable:</p> <pre><code>export RUBY_PROF_MEASURE_MODE=wall\nexport RUBY_PROF_MEASURE_MODE=process\nexport RUBY_PROF_MEASURE_MODE=allocations\n</code></pre>","path":["Advanced Usage"],"tags":[]},{"location":"advanced-usage/#allocation-tracking","level":2,"title":"Allocation Tracking","text":"<p>ruby-prof also has the ability to track object allocations. This functionality can be turned on via the track_allocations option:</p> <pre><code>require 'ruby-prof'\n\nRubyProf::Profile.profile(:track_allocations =&gt; true) do\n  ...\nend\n</code></pre> <p>Note the <code>RubyProf::ALLOCATIONS</code> measure mode is slightly different than tracking allocations. The measurement mode provides high level information about the number of allocations performed in each method. In contrast, tracking allocations provides detailed information about the type, number, memory usage and location of each allocation. Currently, to see allocations results you must use the <code>RubyProf::GraphHtmlPrinter</code>.</p>","path":["Advanced Usage"],"tags":[]},{"location":"advanced-usage/#thread-inclusionexclusion","level":2,"title":"Thread Inclusion/Exclusion","text":"<p>ruby-prof can profile multiple threads. Sometimes this can be overwhelming. For example, assume you want to determine why your tests are running slowly. If you are using minitest, it will run your tests in parallel by spawning tens of worker threads (note to tell minitest to use a single thread set the N environmental variable like this ENV = 0). Thus, ruby-prof provides two options to specify which threads should be profiled:</p> <p>exclude_threads - Array of threads which should not be profiled.</p> <p>include_threads - Array of threads which should be profiled. All other threads will be ignored.</p>","path":["Advanced Usage"],"tags":[]},{"location":"advanced-usage/#method-exclusion","level":2,"title":"Method Exclusion","text":"<p>ruby-prof supports excluding specific methods and threads from profiling results. This is useful for reducing connectivity in the call graph, making it easier to identify the source of performance problems when using a graph printer. For example, consider <code>Integer#times</code>: it's hardly ever useful to know how much time is spent in the method itself. We are more interested in how much the passed in block contributes to the time spent in the method which contains the <code>Integer#times</code> call. The effect on collected metrics are identical to eliminating methods from the profiling result in a post process step.</p> <pre><code>profile = RubyProf::Profile.new(...)\nprofile.exclude_methods!(Integer, :times, ...)\nprofile.start\n</code></pre> <p>A convenience method is provided to exclude a large number of methods which usually clutter up profiles:</p> <pre><code>profile.exclude_common_methods!\n</code></pre> <p>However, this is a somewhat opinionated method collection. It's usually better to view it as an inspiration instead of using it directly (see exclude_common_methods.rb).</p>","path":["Advanced Usage"],"tags":[]},{"location":"advanced-usage/#merging-threads-and-fibers","level":2,"title":"Merging Threads and Fibers","text":"<p>ruby-prof profiles each thread and fiber separately. A common design pattern is to have a main thread delegate work to background threads or fibers. Examples include web servers such as Puma and Falcon, as well as code that uses <code>Enumerator</code>, <code>Fiber.new</code>, or async libraries.</p> <p>Understanding profiling results can be very difficult when there are many threads or fibers because each one appears as a separate entry in the output. To help with this, ruby-prof includes the ability to merge results for threads and fibers that start with the same root method. In the best case, this can collapse results into just two entries - one for the parent thread and one for all workers.</p> <p>Note the collapsed results show the sum of times for all merged threads/fibers. For example, assume there are 10 worker fibers that each took 5 seconds to run. The single merged entry will show a total time of 50 seconds.</p> <p>To merge threads and fibers:</p> <pre><code>profile = RubyProf::Profile.profile do\n            ...\n          end\nprofile.merge!\n</code></pre> <p>This is also supported in the Rack adapter via the <code>merge_fibers</code> option:</p> <pre><code>config.middleware.use Rack::RubyProf, :path =&gt; './tmp/profile', :merge_fibers =&gt; true\n</code></pre>","path":["Advanced Usage"],"tags":[]},{"location":"advanced-usage/#saving-results","level":2,"title":"Saving Results","text":"<p>It can be helpful to save the results of a profiling run for later analysis. Results can be saved using Ruby's marshal library.</p> <pre><code>profile_1 = RubyProf::Profile.profile do\n  ...\nend\n\n# Save the results\ndata = Marshal.dump(profile_1)\n\n# Sometime later load the results\nprofile_2 = Marshal.load(data)\n</code></pre> <p>!!!WARNING!!! - Only load ruby-prof profiles that you know are safe. Demarshaling data can lead to arbitrary code execution and thus can be dangerous.</p>","path":["Advanced Usage"],"tags":[]},{"location":"architecture/","level":1,"title":"Architecture","text":"","path":["Architecture"],"tags":[]},{"location":"architecture/#overview","level":2,"title":"Overview","text":"<p>ruby-prof is a profiler for MRI Ruby. It's built as a C extension and therefore many times faster than the standard Ruby profiler. The image below shows the main classes that make up ruby-prof:</p> <p></p> <p>The top level class is Profile, which is returned by a profiling run:</p> <pre><code>profile = RubyProf.profile do\n            ...\n          end\n</code></pre> <p>A profile owns a hash of threads, and threads in turn own the methods called in that thread as well as call trees which record how the methods were called.</p>","path":["Architecture"],"tags":[]},{"location":"architecture/#memory-management","level":2,"title":"Memory Management","text":"<p>The master object is the Profile object. Each Profile object is responsible for managing the memory of its child objects which are C structures. When the Profile object goes out of scope, it recursively frees all its objects. In the class diagram, this can be seen via the composition relationships. The owning object is denoted with a filled in black diamond. Thus a Profile frees its threads, Threads free their CallTrees and Methods, etc.</p> <p>You should always keep a reference to a Profile object so that you can generate profiling reports. However, RubyProf will keep a Profile object alive, even if it has no direct references, as long as there are live references to either a MethodInfo object or a CallTree object. This is done via the GC mark phase. CallTree instances mark their associated MethodInfo instances, and MethodInfo instances in turn mark their owning Profile instance.</p> <p>Starting with version 1.5 it is possible to create new instances of the Thread, CallTree and MethodInfo classes from Ruby. In general you won't need to use this functionality - it was added to make it easier to write tests. However, this functionality does complicate memory management because some objects are now owned by the C extension while others are owned by Ruby. To track this information an internal ownership flag was added to instances of these classes. RubyProf automatically handles this, but it is important to understand if you are reading or modifying the C code.</p>","path":["Architecture"],"tags":[]},{"location":"getting-started/","level":1,"title":"Getting Started","text":"<p>There are three ways to use ruby-prof:</p> <ul> <li>command line</li> <li>convenience API</li> <li>core API</li> </ul>","path":["Getting Started"],"tags":[]},{"location":"getting-started/#command-line","level":2,"title":"Command Line","text":"<p>The easiest way to use ruby-prof is via the command line, which requires no modifications to your program. The basic usage is:</p> <pre><code>ruby-prof [options] &lt;script.rb&gt; [--] [script-options]\n</code></pre> <p>Where script.rb is the program you want to profile.</p> <p>For a full list of options, see the RubyProf::Cmd documentation or execute the following command:</p> <pre><code>ruby-prof -h\n</code></pre>","path":["Getting Started"],"tags":[]},{"location":"getting-started/#convenience-api","level":2,"title":"Convenience API","text":"<p>The second way to use ruby-prof is via its convenience API. This requires small modifications to the program you want to profile:</p> <pre><code>require 'ruby-prof'\n\nprofile = RubyProf::Profile.new\n\n# profile the code\nprofile.start\n# ... code to profile ...\nresult = profile.stop\n\n# print a flat profile to text\nprinter = RubyProf::FlatPrinter.new(result)\nprinter.print(STDOUT)\n</code></pre> <p>Alternatively, you can use a block to tell ruby-prof what to profile:</p> <pre><code>require 'ruby-prof'\n\n# profile the code\nresult = RubyProf::Profile.profile do\n  # ... code to profile ...\nend\n\n# print a graph profile to text\nprinter = RubyProf::GraphPrinter.new(result)\nprinter.print(STDOUT, {})\n</code></pre> <p>ruby-prof also supports pausing and resuming profiling runs.</p> <pre><code>require 'ruby-prof'\n\nprofile = RubyProf::Profile.new\n\n# profile the code\nprofile.start\n# ... code to profile ...\n\nprofile.pause\n# ... other code ...\n\nprofile.resume\n# ... code to profile ...\n\nresult = profile.stop\n</code></pre> <p>Note that resume will only work if start has been called previously. In addition, resume can also take a block:</p> <pre><code>require 'ruby-prof'\n\nprofile = RubyProf::Profile.new\n\n# profile the code\nprofile.start\n# ... code to profile ...\n\nprofile.pause\n# ... other code ...\n\nprofile.resume do\n  # ... code to profile...\nend\n\nresult = profile.stop\n</code></pre> <p>With this usage, resume will automatically call pause at the end of the block.</p> <p>The <code>RubyProf::Profile.profile</code> method can take various options, which are described in Profiling Options.</p>","path":["Getting Started"],"tags":[]},{"location":"getting-started/#core-api","level":2,"title":"Core API","text":"<p>The convenience API is a wrapper around the <code>RubyProf::Profile</code> class. Using the Profile class directly provides additional functionality, such as method exclusion.</p> <p>To create a new profile:</p> <pre><code>require 'ruby-prof'\n\nprofile = RubyProf::Profile.new(options)\nresult = profile.profile do\n           ...\n         end\n</code></pre> <p>Once a profile is completed, you can either generate a report via a printer or save the results for later analysis. For a list of profiling options, please see the Profiling Options section.</p>","path":["Getting Started"],"tags":[]},{"location":"profiling-rails/","level":1,"title":"Profiling Rails","text":"<p>To profile a Rails application it is vital to run it using production like settings (cache classes, cache view lookups, etc.). Otherwise, Rail's dependency loading code will overwhelm any time spent in the application itself (our tests show that Rails dependency loading causes a roughly 6x slowdown). The best way to do this is create a new Rails environment, profile.rb.</p> <p>To profile Rails:</p> <ol> <li> <p>Create a new profile.rb environment. Make sure to turn on <code>cache_classes</code> and <code>cache_template_loading</code>. Otherwise your profiling results will be overwhelmed by the time Rails spends loading required files. You should likely turn off caching.</p> </li> <li> <p>Add the ruby-prof to your gemfile:</p> </li> </ol> <pre><code>group :profile do\n  gem 'ruby-prof'\nend\n</code></pre> <ol> <li>Add the ruby prof rack adapter to your middleware stack. The Rails documentation describes several ways to do this. One way is to add the following code to <code>application.rb</code>:</li> </ol> <pre><code>if Rails.env.profile?\n  config.middleware.use Rack::RubyProf, :path =&gt; './tmp/profile'\nend\n</code></pre> <p>The path is where you want profiling results to be stored. By default the rack adapter will generate a html call graph report and flat text report.</p> <ol> <li>Now make a request to your running server. New profiling information will be generated for each request. Note that each request will overwrite the profiling reports created by the previous request!</li> </ol>","path":["Profiling Rails"],"tags":[]},{"location":"reports/","level":1,"title":"Reports","text":"<p>Once you have completed a profiling run, ruby-prof provides a number of reports that you can use to analyze the results. Reports are created via the use of printers:</p> <pre><code>profile = RubyProf::Profile.profile do\n            ...\n          end\nprinter = RubyProf::GraphPrinter.new(profile)\nprinter.print(STDOUT, :min_percent =&gt; 2)\n</code></pre> <p>The first parameter is any writable IO object such as <code>STDOUT</code> or a file. The second parameter specifies the minimum percentage a method must take to be printed. Percentages should be specified as integers in the range 0 to 100. For more information please see the documentation for the different printers.</p> <p>The different types of reports, and their associated printers, are:</p>","path":["Reports"],"tags":[]},{"location":"reports/#flat-report-rubyprofflatprinter","level":2,"title":"Flat Report (RubyProf::FlatPrinter)","text":"<p>The flat report shows the overall time spent in each method. It is a good way of quickly identifying which methods take the most time.</p>","path":["Reports"],"tags":[]},{"location":"reports/#graph-reports-rubyprofgraphprinter","level":2,"title":"Graph Reports (RubyProf::GraphPrinter)","text":"<p>The graph report shows the overall time spent in each method. In addition, it also shows which methods call the current method and which methods it calls. Thus they are good for understanding how methods get called and provide insight into the flow of your program.</p>","path":["Reports"],"tags":[]},{"location":"reports/#html-graph-reports-rubyprofgraphhtmlprinter","level":2,"title":"HTML Graph Reports (RubyProf::GraphHtmlPrinter)","text":"<p>HTML Graph profiles are the same as graph reports, except output is generated in hyper-linked HTML. Since graph reports can be quite large, the embedded links make it much easier to navigate the results.</p>","path":["Reports"],"tags":[]},{"location":"reports/#call-stack-reports-rubyprofcallstackprinter","level":2,"title":"Call Stack Reports (RubyProf::CallStackPrinter)","text":"<p>Call stack reports produce a HTML visualization of the time spent in each execution path of the profiled code.</p>","path":["Reports"],"tags":[]},{"location":"reports/#call-tree-rubyprofcalltreeprinter","level":2,"title":"Call Tree (RubyProf::CallTreePrinter)","text":"<p>Call tree output results in the calltree profile format which is used by KCachegrind. More information about the format can be found at the KCachegrind site.</p>","path":["Reports"],"tags":[]},{"location":"reports/#graphviz-reports-rubyprofdotprinter","level":2,"title":"Graphviz Reports (RubyProf::DotPrinter)","text":"<p>The graphviz report is designed to be opened by Graphviz to create visualization of profile results.</p>","path":["Reports"],"tags":[]},{"location":"reports/#call-info-reports-rubyprofcallinfoprinter","level":2,"title":"Call Info Reports (RubyProf::CallInfoPrinter)","text":"<p>Call info reports print the call tree with timing information for each node. This is mainly useful for debugging purposes as it provides access into ruby-prof's internals.</p>","path":["Reports"],"tags":[]},{"location":"reports/#multiple-reports-rubyprofmultiprinter","level":2,"title":"Multiple Reports (RubyProf::MultiPrinter)","text":"<p>MultiPrinter can generate several reports in one profiling run. <code>MultiPrinter</code> requires a directory path and a profile basename for the files they produce:</p> <pre><code>printer = RubyProf::MultiPrinter.new(result)\nprinter.print(:path =&gt; \".\", :profile =&gt; \"profile\")\n</code></pre>","path":["Reports"],"tags":[]}]}